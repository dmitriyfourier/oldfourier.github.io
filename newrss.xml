<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[Павел Радьков]]></title>
        <description><![CDATA[Заметки о веб-разработке Павла Радькова.]]></description>
        <link>http://dmitriyfourier.github.io</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Thu, 03 Jun 2021 11:12:44 GMT</lastBuildDate>
        <atom:link href="http://dmitriyfourier.github.io/newrss.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Павел Радьков]]></author>
        <pubDate>Thu, 03 Jun 2021 11:12:19 GMT</pubDate>
        <item>
            <title><![CDATA[Как правильно использовать переменные в препроцессорах Less и Sass]]></title>
            <description><![CDATA[История архитектурной ошибки, её последствия, и три правила, благодаря которым вы сможете держать исходный код в порядке и снизить стоимость внесения изменений.

<!-- cut -->

<a name="prehistory" id="prehistory"></a>

<aside class="article-grid--incut article-grid--incut-row-3 space-out-top-mega-xl">
    <ol class="local-nav">
        <li><a href="#prehistory">Предыстория</a></li>
        <li><a href="#problems">Проблемы</a></li>
        <li><a href="#solutions">Как решать</a></li>
        <li><a href="#onLess">Реализация на Less</a></li>
        <li><a href="#onSass">Реализация в Sass</a></li>
        <li><a href="#conclusion">Выводы</a></li>
        <li><a href="#examples">Реальные примеры</a></li>
        <li><a href="#bonus">Бонус-трек</a></li>
        <li><a href="#disqus_thread" data-disqus-identifier="local_variables">Комментарии</a></li>
    </ol>
</aside>

## Предыстория

В 2014 году в компании начали редизайн проекта и в основу вёрстки мы положили свежий на тот момент Bootstrap 3.0.1. Использовали мы его не как отдельную стороннюю библиотеку, а тесно заинтегрировали с нашим собственным кодом: отредактировали переменные под наш дизайн и компилировали кастомизированный Бутстрап из Less исходников самостоятельно. Проект оброс собственными модулями, которые использовали бутстраповские переменные и добавляли в файл с настройками свои новые переменные.

В тот момент я думал, что это правильный подход. Ведь код сразу компилируется с нужными значениями без переопределения стилей. CSS чистый, компактный и без повторений. Компоненты стилизованы с помощью глобальных настроек.

Через год с небольшим редизайн закончился, проект вышел в продакшн, и мы взялись за технический долг. При попытке обновить Бутстрап до версии 3.6.x выяснилось, что смержить новый variables.less с нашим файлом настроек будет нелегко. В Бутстрапе переименовали или убрали часть переменных, добавили новые. Собственные компоненты Бутстрапа обновились без проблем, а вот наши компоненты падали при компиляции из-за этих изменений.

<a name="problems" id="problems"></a>

## Проблемы

Мы проанализировали ситуацию и сформулировали проблемы.

1. **Слишком связанный код.**

  Сами компоненты лежали в отдельных файлах. Это создавало иллюзию, что компоненты независимые. Но компоненты использовали переменные, объявленные в отдельном файле variables.less, и без этого файла не работали. Нельзя было просто так взять и переместить компонент в другой проект. Приходилось тянуть за собой файл с настройками, который со временем превратился в помойку.

2. **Слишком много глобальных переменных**.

  У Бутстрапа было ≈400 переменных. Мы отключили неиспользуемые компоненты Бутстрапа, но переменные оставили в конфиге на случай, если снова понадобятся. Еще мы добавили сотню или полторы своих переменных. Все названия не запомнить, трудно быстро находить нужные. Даже с правилами именования и комментариями ориентироваться в конфиге из 500+ переменных тяжело.

3. **Имена глобальных переменных вышли из-под контроля**.

  Одна и та же переменная могла использоваться в разных файлах и отслеживать все её появления в коде было долго и трудно. Когда меняли значение переменной в одном компоненте, был риск поломать другие компоненты. Разработчики хардкодили, создавали новые переменные с похожими названиями и значениями и уже не следили за логикой именования.

<a name="solutions" id="solutions"></a>

## Как решать

Я придумал три правила, которые помогли побороть наши проблемы:

<ol class="ol-important space-in-h-zero-xs space-in-h-base-sm">
    <li>
        <p class="text-custom-number text-important text-center space-in-wide-base-xs space-in-wide-kilo-md space-out-v-base-xs space-minus-h-base-sm " data-number="1">**Переменная используется только в том файле, в котором объявлена.**</p>
        <p>Правильно создавать все нужные переменные в файле самого компонента и не использовать переменные из других файлов. Тогда компоненты станут независимыми, их можно будет подключать и перемещать между проектами без поломок при компиляции. У каждого компонента собственный набор переменных, которые запрещено использовать в других компонентах и вызывать в других файлах. Когда переменные не выходят за пределы одного файла, легко увидеть, как они используются и на что влияют.</p>
    </li>
    <li>
        <p class="text-custom-number text-important text-center space-in-wide-base-xs space-in-wide-kilo-md space-out-v-base-xs space-minus-h-base-sm " data-number="2">**Все переменные внутри компонента — локальные.**</p>
        <p>Раз у каждого компонента свои переменные, пусть они будут локальными. Это избавит от проблем с именованием: в компонентах можно использовать переменные с одинаковыми именами и разными значениями — они не будут конфликтовать друг с другом.</p>
    </li>
    <li>
        <p class="text-custom-number text-important text-center space-in-wide-base-xs space-in-wide-kilo-md space-out-v-base-xs space-minus-h-base-sm " data-number="3">**Глобальные переменные используются только внутри файла настроек.**</p>
        <p>Благодаря первым двум правилам мы сильно сократим количество глобальных переменных, но они всё равно нужны. Глобальные переменные объявляются в главном файле проекта или в файле типа config.less. К ним тоже применяется правило №1 — переменные не используются за пределами своего файла. Это значит, что нельзя использовать глобальные переменные внутри файлов компонентов. Но существует способ не нарушая первого правила прокинуть значение глобальной переменной внутрь компонента. Как это сделать мы рассмотрим на примерах далее.</p>
    </li>
</ol>

Третье правило избыточное. Соблюдая первые два, вы автоматически соблюдаете третье. Но в реальной жизни есть очень большой соблазн пойти по простейшему пути, не создавать локальную переменную, а по-быстрому использовать глобальную. Третье правило напоминает, что так делать вредно, что это создаёт ненужные зависимости и приводит к связыванию кода.

Применим правила на практике.

<a name="onLess" id="onLess"></a>

## Реализация на Less

Представим простейший компонент для стилизации страницы. Согласно правилу №1 создадим переменные внутри файла компонента.

<aside class="article-grid--aside txt-aside">
    <dl>
        <dt>Правило 1</dt>
        <dd>Переменная используется только в том файле, в котором объявлена.</dd>
    </dl>
</aside>

<figure class="space-out-h-kilo-xl">
    <div class="row row-middle-xs">
        <section class="col-xs-12 col-md space-minus-right-giga-md">
            <div class="browserframe" data-title="page.css">
                ```css
/* page.css */

.page {
    padding: 40px;
    color: #000;
    background-color: #fff;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Было.</strong> Пример кода компонента.</figcaption>
        </section>
        <section class="col-xs-12 col-md-1">
            <p>↓</p>
        </section>
        <section class="col-xs-12 col-md">
            <div class="browserframe" data-title="page.less">
                ```less
// page.less v0.1

@padding: 40px;
@txt-color: #000;
@bg-color: #fff;

.page {
    padding: @padding;
    color: @txt-color;
    background-color: @bg-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Стало.</strong> Переменные объявлены в глобальной области видимости и у них слишком общие имена. Это плохо.</figcaption>
        </section>
    </div>
</figure>

В примере выше мы объявили переменные в глобальной области видимости и из-за этого они подвержены конфликту имён. Если в соседнем компоненте появится переменная с таким же именем, то компоненты поломают друг друга.


### Локальные переменные

**Область видимости** — это «пространство» между фигурными скобками селектора: { и } . Объявленные внутри фигурных скобок переменные работают только внутри этих скобок и внутри дочерних скобок, но их нельзя использовать снаружи.

Если скобок вокруг нет, то это самый верхний уровень — **глобальная область видимости**.

У переменной из дочерней области видимости приоритет выше, чем у одноименной переменной из родительской области видимости. У глобальных переменных самый низкий приоритет при совпадении имён.

По правилу №2 сделаем переменные локальными — переместим их внутрь селектора.

<aside class="article-grid--aside txt-aside">
    <dl>
        <dt>Правило 2</dt>
        <dd>Все переменные внутри компонента — локальные.</dd>
    </dl>
</aside>

<figure class="space-out-h-kilo-xl">
    <div class="row row-middle-xs">
        <section class="col-xs-12 col-md space-minus-right-giga-md space-auto-top-md">
            <div class="browserframe" data-title="page.less">
                ```less
// page.less v0.1

@padding: 40px;
@txt-color: #000;
@bg-color: #fff;

.page {
    padding: @padding;
    color: @txt-color;
    background-color: @bg-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Было.</strong> Глобальные переменные.</figcaption>
        </section>
        <section class="col-xs-12 col-md-1">
            <p>↓</p>
        </section>
        <section class="col-xs-12 col-md">
            <div class="browserframe" data-title="page.less">
                ```less
// page.less v0.2

.page {
    @padding: 40px;
    @txt-color: #000;
    @bg-color: #fff;

    padding: @padding;
    color: @txt-color;
    background-color: @bg-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Стало.</strong> Переменные объявлены внутри селектора и не создают конфликта имён, потому что теперь они локальные.</figcaption>
        </section>
    </div>
</figure>

Теперь конфликта имен с другими компонентами не будет. Мы решили первую и вторую проблемы: получился изолированный сниппет без внешних зависимостей. Но я не знаю способа переопределить локальные переменные компонента в таком виде извне. Поэтому, чтобы кастомизировать компоненты глобальными переменными проекта, придумал другую форму записи.

### Миксины как функции

В Less можно использовать миксины как функции. Если внутри миксина создать переменные, а потом вызвать миксин внутри селектора, то переменные будут доступны в области видимости этого селектора.

<aside class="article-grid--aside txt-aside">
    <p>Читайте про <a href="http://lesscss.org/features/#mixins-as-functions-feature" target='_blank'>миксины как функции</a> в документации Less.</p>
</aside>

Вынесем объявление переменных внутрь миксина `.page-settings()`, а потом вызовем его внутри селектора `.page`:

<figure class="space-out-h-kilo-xl">
    <div class="row row-middle-xs">
        <section class="col-xs-12 col-md space-minus-right-giga-md">
            <div class="browserframe" data-title="page.less">
                ```less
// page.less v0.2

.page {
    @padding: 40px;
    @txt-color: #000;
    @bg-color: #fff;

    padding: @padding;
    color: @txt-color;
    background-color: @bg-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Было.</strong> Локальные переменные внутри селектора.</figcaption>
        </section>
        <section class="col-xs-12 col-md-1">
            <p>↓</p>
        </section>
        <section class="col-xs-12 col-md">
            <div class="browserframe" data-title="page.less">
                ```less
// page.less v0.3

.page-settings() {
    @padding: 40px;
    @txt-color: #000;
    @bg-color: #fff;
}

.page {
    .page-settings();

    padding: @padding;
    color: @txt-color;
    background-color: @bg-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Стало.</strong> Миксин доставляет переменные в зону видимости селектора.</figcaption>
        </section>
    </div>
</figure>

Переменные локализованы внутри глобального миксина. Когда мы вызвали миксин в коде, переменные стали доступны в области видимости селектора `.page`, но по прежнему остались локальными.

Такой миксин не генерирует CSS код, его единственная задача — доставить переменные в нужную область видимости. Например, если вызвать этот миксин в глобальной области видимости, то и переменные станут глобальными. Но это то же самое, что сразу объявить переменные глобально.

Вместо нескольких глобальных переменных с распространёнными именами мы создали один глобальный миксин. В проекте не должно быть двух одноименных компонентов, значит имя миксина будет уникальным.


### Слияние миксинов

В Less существует «ленивое вычисление» переменных: не обязательно объявлять Less-переменную перед её использованием, можно объявить после. В момент компиляции парсер Less найдет определение переменной и отрендерит значение этой переменной в CSS.

<aside class="article-grid--aside article-grid--aside-row-2 txt-aside">
    <p>Смотрите <a href="http://lesscss.org/features/#variables-feature-lazy-evaluation" target='_blank'>примеры «Lazy Evaluation»</a> и <a href="http://lesscss.org/features/#variables-feature-default-variables" target='_blank'>переопределения дефолтных переменных</a> в документации Less.</p>
</aside>

Если переопределить переменную, то во всех местах её использования в силу вступит значение из самого последнего определения, так как оно приоритетнее по порядку следования в исходном коде. В этом смысле переменные ведут себя как константы.

Итак, переменные можно объявлять и до, и после использования, а миксины — это разновидность переменных. Если создать два миксина с одним и тем же именем и разным содержанием, то они объединяют свои внутренности. А если внутри миксинов есть переменные с одинаковыми именами, то происходит переопределение. Приоритет выше у последнего миксина.

Рассмотрим три файла:

<figure class="space-out-h-kilo-xl">
    <div class="row row-bottom-xs row-center-xs row-middle-lg">
        <section class="col-xs-12 col-md-6 col-lg-shrink col-xl space-minus-right-base-md space-minus-right-kilo-lg">
            <div class="browserframe" data-title="projectname.less">
                ```less
// projectname.less

@import 'normalize.css';
@import 'typography.less';
@import 'page.less';
// и много других компонентов...

@import 'config.less';
```
            </div>
            <figcaption class="space-in-h-mili-md space-in-h-base-lg"><strong>Главный файл.</strong><br> Импортируем компоненты и конфиг. Конфиг — последним.</figcaption>
        </section>
        <section class="col-xs-12 col-md-6 col-lg-shrink col-xl space-minus-right-kilo-lg">
            <div class="browserframe" data-title="page.less">
                ```less
// page.less v0.3

.page-settings() {
    @padding: 40px;
    @txt-color: #000;
    @bg-color: #fff;
}

.page {
    .page-settings();

    padding: @padding;
    color: @txt-color;
    background-color: @bg-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md space-in-h-base-lg"><strong>Компонент.</strong><br> Все переменные локальные и хранятся в миксине.</figcaption>
        </section>
        <section class="col-xs-12 col-md-shrink col-lg-shrink col-xl">
            <div class="browserframe" data-title="config.less">
                ```less
// config.less

@glob-text-color: white;
@glob-bg-color: darkblue;

// кастомизация компонентов
.page-settings() {
    @txt-color: @glob-text-color;
    @bg-color: @glob-bg-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md space-in-h-base-lg"><strong>Конфиг проекта.</strong><br> Переопределяем параметры компонента с помощью миксина настроек.</figcaption>
        </section>
    </div>
</figure>

Всё самое интересное происходит в конфиге. Мы создали глобальные переменные и использовали их в этом же файле для кастомизации компонента.

Миксин `.page-settings()` объявлен два раза. Первый раз внутри файла `page.less` с дефолтными значениями, второй раз в файле `config.less` с новыми значениями. На этапе компиляции миксины склеиваются, новые переменные переопределяют дефолтные и CSS рендерится с новыми значениями из файла конфигурации.

<aside class="article-grid--aside txt-aside">
    <dl>
        <dt>Правило 3</dt>
        <dd>Глобальные переменные используются только внутри файла настроек.</dd>
    </dl>
</aside>

Обратите внимание, что `config.less` инклюдится последним в списке. Это нужно, чтобы объявление миксина в конфиге имело больший приоритет, чем исходное объявление в файле самого компонента. Настройки не применятся, если поставить `config.less` до компонента, потому что на миксины тоже действуют правило «последнее определение — самое сильное».

Таким способом мы прокинули значения глобальных переменных внутрь файла компонента, не меняя исходный код компонента. При этом были соблюдены все три правила:

1. переменные использовались только в своём файле, даже глобальные переменные не вызывались за пределами файла `config.less`;
2. переменные компонента остались локальными и не засорили глобальную область видимости;
3. глобальные переменные не использовались внутри компонента напрямую, но значения глобальных переменных хитрым способом попали внутрь компонента.


### Ограничения

Нельзя, чтобы имя глобальной переменной совпадало с именем локальной — получим рекурсию и CSS не скомпилируется.
Чтобы не ошибиться, лучше все глобальные переменные записывать с префиксом.

<figure class="space-out-h-kilo-xl">
    <div class="row row-middle-xs">
        <section class="col-xs-12 col-md space-minus-right-mega-md">
            <div class="browserframe" data-title="config.less" style="background-color: #fff4f4;">
                ```less
// так нельзя

@txt-color: white;

.page-settings() {
    // тут рекурсия и ошибка компиляции
    @txt-color: @txt-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Неправильно.</strong> Рекурсивное определение переменной вызывает ошибку компиляции.</figcaption>
        </section>
        <section class="col-xs-12 col-md-1">
            <p>↓</p>
        </section>
        <section class="col-xs-12 col-md">
            <div class="browserframe" data-title="config.less">
                ```less
// правильно — с префиксом

@glob-txt-color: white;

.page-settings() {
    // всё в порядке
    @txt-color: @glob-txt-color;
}
```
            </div>
            <figcaption class="space-in-h-mili-md"><strong>Правильно.</strong> У глобальных переменных свой префикс `glob-`, что исключает совпадение имён.</figcaption>
        </section>
    </div>
</figure>

<a name="onSass" id="onSass"></a>

## Реализация в Sass

Sass отличается от Less и больше похож на скриптовый язык программирования: нет «ленивых вычислений» и переменная должна быть обязательно объявлена до её использования в коде. Если определить переменную и использовать её в коде, а потом переопределить и использовать ещё раз, то в первый вызов получим исходное значение в CSS, а во второй вызов новое значение. Трюк с миксинами, как в Less, не пройдет. Но есть другие пути решения.

Наборы переменных для настройки компонента удобно хранить в <dfn>map-объектах</dfn>. Это массив из пар «ключ: значение». Метод <dfn>map-get</dfn> извлекает конкретное значение из массива, метод <dfn>map-merge</dfn> объединяет два массива в один, дополняя или переписывая исходный массив.

<aside class="article-grid--aside txt-aside">
 <p>Читайте <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#maps" target="_blank" rel="noopener">про Maps</a> в документации Sass.</p>
</aside>

Простейший компонент без возможности переопределения извне будет выглядеть так:

<figure class="space-auto-h-xs" style="max-width: 50em;">
    <div class="row row-middle-xs">
        <section class="col-xs-12">
            <div class="browserframe" data-title="page.scss">
                ```scss
// page.scss v0.1

$page-settings: (
    padding: 40px,
    bg-color: #fff,
    text-color: #000,
);

.page {
    padding:          map-get($page-settings, padding);
    background-color: map-get($page-settings, bg-color);
    color:            map-get($page-settings, text-color);
}
```
            </div>
            <figcaption>Настройки хранятся в **map**-объекте и вызываются в коде с помощью **map-get**</figcaption>
        </section>
    </div>
</figure>

Чтобы настраивать компонент из другого файла, нужно предусмотреть возможность смержить внешний конфиг с исходными настройками. Рассмотрим три файла:

<figure class="space-out-h-kilo-xl">
    <div class="row row-bottom-xs row-center-xs">
        <section class="col-xs-12 col-md-6 space-minus-right-kilo-md">
            <div class="browserframe" data-title="projectname.scss">
                ```scss
// projectname.scss

@import: 'config';

@import: 'normalize';
@import: 'typography';
@import: 'page';
// и много других компонентов...
```
            </div>
            <figcaption class="space-in-h-mili-md space-in-h-base-lg"><strong>Главный файл.</strong><br> Сначала импортируем конфиг, потом компоненты.</figcaption>
        </section>
        <section class="col-xs-12 col-md col-lg-6">
            <div class="browserframe" data-title="config.scss">
                ```scss
// config.scss

$glob-text-color: white;
$glob-bg-color: darkblue;

// кастомизируем
$page-settings: (
    bg-color: $glob-bg-color,
    text-color: $glob-text-color,
);
```
            </div>
            <figcaption class="space-in-h-mili-md space-in-h-base-lg"><strong>Настройки.</strong><br> Создаём глобальные переменные и переопределяем параметры компонента.</figcaption>
        </section>
        <section class="col-xs-12 col-md-shrink">
            <div class="browserframe" data-title="page.scss">
                ```scss
// page.scss v0.2

$page-override: ( ); // [1]

@if variable-exists(page-settings) {
    $page-override: $page-settings; // [2]
}

$page-settings:  map-merge((
    padding: 40px,
    bg-color: #fff,
    text-color: #000,
), $page-override); // [3]

.page {
    padding:          map-get($page-settings, padding);
    background-color: map-get($page-settings, bg-color);
    color:            map-get($page-settings, text-color);
}
```
            </div>
            <figcaption class="space-in-h-mili-md space-in-h-base-lg"><strong>Компонент.</strong><br> Добавили проверку: а не существуют ли уже настройки, чтобы переопределить компонент?</figcaption>
        </section>
    </div>
</figure>

`[1]` — В компоненте мы сначала объявили переменную с пустым массивом  `$page-override`.

`[2]` — Потом проверили, а не существует ли уже переменная `$page-settings`. И если она уже была объявлена в конфиге, то присвоили её значение переменной `$page-override`.

`[3]` — И потом смержили исходный конфиг и `$page-override` в переменную `$page-settings`.

Если массив `$page-settings` был объявлен ранее в глобальном конфиге, то `$page-override` перепишет настройки при слиянии. Иначе в переменной `$page-override` будет пустой массив, и в настройках останутся исходные значения.

<aside class="article-grid--aside article-grid--aside-row-2 txt-aside">
    <p>Я не знаю всех тонкостей Sass, может есть способ реализовать эту методику более красивым способом.</p>
</aside>

В результате, мы получаем всё те же преимущества, только в отличие от Less нам приходится переопределять все настройки заранее, перед их использованием в коде.

<a name="conclusion" id="conclusion"></a>

## Выводы

Не важно на чем вы пишете — на Less, Sass, CSS c кастомными свойствами или Javascript — глобальных переменных должно быть как можно меньше.

С CSS препроцессорами используйте три правила, которые помогут избежать хаоса:

  1. **Переменная используется только в том файле, в котором объявлена.**
  2. **Все переменные внутри компонента — локальные.**
  3. **Глобальные переменные используются только внутри файла настроек.**

Чтобы прокинуть глобальные настройки внутрь компонента, собирайте переменные в миксин (Less) или map-объект (Sass).

Переопределяйте настройки в правильном месте: в Less — после инклюда, в Sass — перед инклюдом.

<figure class="article-grid--fullscreen">
    <img src="/2017/local_variables/local_variables_less@1x.png" width="1440" height="720"
        srcset="/2017/local_variables/local_variables_less@05x.png 0.5x,
        /2017/local_variables/local_variables_less@1x.png 1x,
        /2017/local_variables/local_variables_less@2x.png 2x"
        alt="Правила управления переменными в препроцессорах и методика переопределения настроек в одной картинке">
    <figcaption>
        <p>Правила управления переменными в препроцессорах и методика переопределения настроек</p>
    </figcaption>
</figure>


<a name="examples" id="examples"></a>

## Реальные примеры

Я сформулировал эту методику в декабре 2015 года для Less и с тех пор применяю её на рабочих и личных проектах.

За полтора года появилось несколько публичных npm-пакетов. Посмотрите исходный код для лучшего понимания, как работает эта методика в реальных ситуациях.

[bettertext.css](https://github.com/paulradzkov/bettertext.css/blob/master/bettertext.less) — типографика для сайтов. Настраивается при помощи 11 переменных, остальные 40 вычисляются по формулам. Вычисления идут отдельными миксином, чтобы была возможность переопределять формулы. У компонента нет ни одного класса, все стили применяются к тегам. Чтобы создать локальную область видимости, я поместил все селекторы по тегам в переменную — в Less это называется «detached ruleset».

<aside class="article-grid--aside txt-aside space-auto-top-xl space-in-bottom-nano-xl">
    <p>Читайте про <a href="http://lesscss.org/features/#detached-rulesets-feature" target='_blank'>detached ruleset</a> в документации Less.</p>
</aside>

[links.less](https://github.com/paulradzkov/links.less/blob/master/links.less) — стили для ссылок с фокусом, анимацией и бледным подчеркиванием. У компонента кроме миксина с настройками есть дополнительные глобальные миксины для раскрашивания ссылок внутри ваших собственных селекторов.

[flxgrid.css](https://github.com/paulradzkov/flxgrid.css/blob/master/flxgrid.less) — генератор HTML-сеток на флексах. Настраивается при помощи 5 переменных, генерирует классы для адаптивной сетки с любыми брейкпоинтами и любым количеством колонок. В компоненте вычисления и служебные миксины спрятаны внутрь локальной области видимости. Глобально виден только миксин с настройками.

[space.less](https://github.com/paulradzkov/space.less/blob/master/space.less) — инструмент для управления отступами в вёрстке. Создан, чтобы работать в паре с сеткой flxgrid.css. Адаптивность у них настраивается одинаково, но space.less использует собственный миксин настройки и собственные локальные переменные — в коде space.less никак не связан с flxgrid.css.

<a name="bonus" id="bonus"></a>

## «Бонус-трек»

Если бы мне сейчас понадобилось использовать на новом проекте Bootstrap 3.x.x — тот, который на Less, — я бы все импортируемые модули Бутстрапа завернул в переменную (в «detached ruleset»), а все настройки из файла `variables.less` в миксин `bootsrtap-settings`. Глобальные переменные Бутстрапа перестали бы быть глобальными и их невозможно было бы использовать внутри собственного кода. Настройки Бутстрапа я бы кастомизировал по мере необходимости, вызывая миксин `bootsrtap-settings` в конфиге проекта, так же как в примерах выше. Тогда при обновлениях Бутстрапа пришлось бы поправить только миксин с кастомизированными настройкам.]]></description>
            <link>http://dmitriyfourier.github.io/2017/local_variables/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2017/local_variables/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Как верстальщику получить код ревью]]></title>
            <description><![CDATA[**По мотивам вопроса на тостере «[Где найти того, кто оценит твой код?](https://toster.ru/q/289819)»**

Упростите жизнь ревьюверам. Постарайтесь, чтобы оценка кода занимала у них как можно меньше времени, а отправлять комментарии и исправления было легко. Чем меньше усилий потребуется со стороны ревьювера, тем выше шанс получить код ревью.

<!-- cut -->

## Код — на Гитхабе

Отправлять почтой zip-архив и просить посмотреть — неудобно для ревьювера. Некоторые откажутся сразу. Кто-то согласится, но не сделает. У оставшихся возникнет проблема, в каком виде отправить вам комментарии и замечания назад.

Для маленьких и простых вещей делайте демку на [http://codepen.io](http://codepen.io) и похожих  сервисах. Открыть ссылку, посмотреть код и результат, форкнуть, исправить или оставить пару комментариев там не займет много времени. И даже не придется открывать текстовый редактор или IDE.

Сайты, одностраничники, свёрстанные макеты заливайте на [GitHub Pages](https://pages.github.com/). Для этого вам придется разобраться с git, но git вам точно понадобится. Код на GitHub удобно просматривать и оставлять комментарии к конкретным строкам, ссылаться на другие файлы и строки внутри них. Ревьювер может исправить ваш код, отправить исправления через pull request и прокомментировать, почему он так сделал. А вы увидите на одном экране старую версию кода, исправленную и комментарии к исправлениям.

К тому же, не покупая домен и хостинг, вы соберете себе портфолио на GitHub.

## Только готовые работы

Выставляйте на ревью готовые работы: когда вы сами уже исправили всё, что заметили, и улучшили всё, что могли. Иначе ревьювер найдёт несколько самых очевидных косяков и перестанет искать дальше. Решит, что «для начала достаточно», или выдаст резюме, что «тут совсем всё плохо» и «надо полностью переверстать». Вы потратите время другого человека и не получите пользы.

Если вас интересует мнение по поводу части какой-либо незаконченной работы, просите посмотреть конкретный файл с указанием номеров строк. А лучше сделайте изолированный пример на codepen.io, чтобы «сырой» код не отвлекал ревьювера. Чем меньше кода покажешь ревьюверу, тем внимательнее он его посмотрит.

## На ревью — по одному

Если у вас готово несколько работ, то на ревью их выставляйте по одной. Не просите посмотреть всё сразу. Вероятно, вы совершаете систематические ошибки, которые присутствуют во всех работах. Когда вам указали на ошибки в первой работе, исправляйте эти ошибки в остальных и только потом показывайте следующую работу ревьюверам. Так вы научитесь большему, написав меньше кода ~~и задолбав меньше ревьюверов~~.

А ещё уговорить кого-то посмотреть маленький кусочек кода проще, чем просить оценить сразу все ваши проекты.

## Сопроводительная информация

Ревьювер захочет узнать, как выглядит исходник дизайна, который вы сверстали, какие требования к вёрстке поставлены в техническом задании, поддержка браузеров и размеров экранов. Но ревьювер не захочет качать 100Мб исходников и рыться в длинном документе в поисках технических требований.

Кратко опишите требования, что и зачем вы делали, оставьте ссылку на скриншот дизайна.

## Задавайте конкретные вопросы

Помогите ревьюверу помочь вам. Укажите, в каких местах у вас возникли проблемы. Спрашивайте, если сомневаетесь в своих решениях. Отвечать на конкретные вопросы проще, чем на общие типа «всё ли в порядке с моей вёрсткой». Поверните обсуждение в нужное вам русло.

## Запаситесь скриншотами

Ревьювер посмотрит вёрстку в своём любимом браузере и вряд ли посмотрит в другом. Если у вас проблемы в каком-либо конкретном браузере, прикрепите скриншот проблемы или [сделайте гифку](http://paulradzkov.com/2014/capture_screen_to_gif/). Лучше один раз увидеть, чем пять раз перечитать описание.

## Где искать ревьюверов

Когда вам будет что показать, отправляйте ссылки на код знакомым и незнакомым профессионалам, оставляйте сообщения в профильных сообществах и на форумах. Например, на [http://htmlforum.ru](http://htmlforum.ru/) или [https://toster.ru](https://toster.ru).

## Итоги

Следование этим рекомендациям избавит ревьювера от лишней работы, упростит и ускорит процесс оценки кода. А вы получите конструктивные советы и замечания.

Покажите человеку, что вы цените его время, и тогда он захочет помочь вам.]]></description>
            <link>http://dmitriyfourier.github.io/2016/code_review/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2016/code_review/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Веб-лицензии для платных шрифтов могут стоить вам дорого]]></title>
            <description><![CDATA[Использовать платные шрифты в вебе бывает неоправдано дорого. Веб-лицензия, в отличие от настольной лицензии, подразумевает не покупку файлов шрифта, а аренду @font-face версии этого шрифта, причем стоимость аренды зависит от посещаемости вашего сайта. Самая главная опасность платных шрифтов в том, что это не разовые, а _постоянные_ затраты.

<!-- cut -->

## Отличия в лицензиях

**Настольная лицензия** (desktop license):
Вы один раз покупаете ttf-файлы шрифта, устанавливаете их себе на компьютер и можете неограниченно использовать в графических редакторах или на печати.

Если вы сконвертируете купленный шрифт для использования в вебе, то это будет нарушением настольной лицензии, т.к. файлы шрифта не остаются _только_ на вашем компьютере, а загружаются на компьютер посетителя вашего сайта. Поэтому популярные конвертеры, типа fontsquirrel, блокируют преобразование платных шрифтов.

**Веб-лицензия** (webfont license):
Вы не покупаете шрифт, вы берете его в аренду. При аренде вам дают ссылку на подключение шрифта к вашей странице (как в Google Fonts) и вы оплачиваете количество обращений по этой ссылке. Существует несколько моделей оплаты:

  * Можно оплатить заранее определённое количество просмотров (pageviews) без ограничений по времени. При такой оплате нужно приобретать каждое начертание шрифта отдельно: например, Normal, Italic, Bold, Bold Italic. Каждая загрузка страницы будет крутить счётчик числа обращений к шрифту. Когда количество оплаченных просмотров будет заканчиваться, вам придет сообщение с просьбой докупить ещё. Если вы не продлили аренду, то шрифт перестанет загружаться — позаботьтесь об адекватной замене системным шрифтом! Но можно настроить автопродление подписки, деньги будут списываться автоматически а посетители вашего сайта всегда будут видеть правильные шрифты.

    Для сайта с небольшой посещаемостью такой способ подписки вполне приемлем, предоплаченного количества посещений хватит надолго. Но если у вас нагруженный ресурс, то деньги будут улетать с большой скоростью.

  * Можно оплатить ежемесячную подписку на шрифт. Стоимость подписки будет зависеть от максимального количества просмотров вашего сайта в месяц. Например, вы берёте подписку на план c ограничением, например, в 1&thinsp;500&thinsp;000 просмотров в месяц. Если в какой-то месяц количество посещений вашего сайта превысит ограничение, вам будет предложено перейти на более дорогой тарифный план. Для особо нагруженных сайтов существуют планы подписок с возможностью размещения файлов шрифта на своих серверах.

  * Некоторые сервисы предлагают ежемесячные подписки с неограниченным количеством шрифтов и их начертаний для сайта, но с единственным ограничением на количество просмотров в месяц.

Стоит отметить, что если платный шрифт у вас не используется на странице, но объявлен в css, то каждая загрузка такой страницы будет крутить счетчик показов шрифта.

## Цены

Предположим нам нужно купить Helvetica Neue в четырех начертаниях: Normal, Italic, Bold, Bold Italic для сайта с 1,5 млн. просмотров в месяц.

Для сравнения настольной и веб-лицензии: на cайте издательства [Linotype][] по настольной лицензии этот набор обойдется в 116€. Веб-шрифт на 1 500 000 просмотров у Линотайпа обойдется в 309€. В год уже получается 3708€. Это 5133$ в год — невероятно много.

На [MyFonts.com][] уже дешевле — 279$ за 1 500 000, что есть 3348$ в год.

В случае ежемесячной оплаты с ограничением по максимальному количеству [Fonts.com][] просит 78€ (100$) в месяц за 2,5 млн. просмотров.
Уже лучше: мы не ограничены количеством начертаний, у нас есть запас на рост посещаемости и всё это стоит 1200$ в год.

Самым выгодным вариантом является [Adobe Typekit][typekit] c его предложением 40$ в месяц за 2 млн. просмотров. Это 480$ в год. Цена уже более менее адекватная, но на неё всё равно согласится не каждый, учитывая, что можно найти [бесплатный аналог](/2014/free_substitution_for_helvetica_neue/) и избежать этих затрат.

Как видим, цены на одно и то же могут отличаться в 10 раз.

[Linotype]: http://www.linotype.com/1266/NeueHelvetica-family.html
[MyFonts.com]: http://www.myfonts.com/fonts/linotype/neue-helvetica/buy.html
[Fonts.com]: http://www.fonts.com/web-fonts/plans-and-pricing
[typekit]: https://typekit.com/plans/business

<div class="fotorama">
    ![Настольная лицензия на сайте Linotype стоит 116€](/2014/web-fonts_license/linotype-helvetica-desktop.png)
    ![Веб-шрифт на Linotype стоит 309€ за 1,5 млн. просмотров](/2014/web-fonts_license/linotype-helvetica-web.png)
    ![Цены на Helvetica на MyFonts.com](/2014/web-fonts_license/myfonts-helvetica-1500000.png)
    ![Тарифные планы на Fonts.com](/2014/web-fonts_license/font-com-pricing.png)
    ![У Adobe Typekit можно взять недорогой план для сайтов с малым посещением](/2014/web-fonts_license/typekit-annual-pricing.png)
    ![Самым выгодным вариантом является Adobe Typekit c его предложением 40$ в месяц за 2 млн. просмотров](/2014/web-fonts_license/typekit-business-pricing.png)
</div>

## Выводы

Стоимость использования платных шрифтов на нагруженных проектах за несколько лет (а то и месяцев) может превысить стоимость создания дизайна самого сайта.

Так как выбор шрифтов — ответственность дизайнеров, им следует знать, что:

* Использование бесплатных шрифтов упрощает жизнь верстальщикам и владельцам сайта.

* Настольной лицензии недостаточно. Если вы передаёте заказчику шрифты, купленные по настольной лицензии, то это только для того, чтобы заказчик смог пользоваться вашими исходниками. Заказчик не имеет права конвертировать их в веб-шрифты.

* Если дизайнер хочет использовать платный шрифт, ему следует поинтересоваться у заказчика о посещаемости сайта и предупредить о вероятных затратах на использование платных шрифтов, чтобы потом не было сюрпризов.

* Веб-версии шрифтов дешевле арендовать у крупных шрифтовых порталов, чем напрямую у издательств.]]></description>
            <link>http://dmitriyfourier.github.io/2014/web-fonts_license/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/web-fonts_license/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Бесплатная замена платному Helvetica Neue]]></title>
            <description><![CDATA[Подбирал бесплатную замену платному Helvetica Neue. До финала дошли:

* [TeX Gyre Heros](http://www.fontsquirrel.com/fonts/TeX-Gyre-Heros)
* [Arimo](http://www.fontsquirrel.com/fonts/Arimo)
* [Liberation Sans](http://www.fontsquirrel.com/fonts/Liberation-Sans)
* [Lato](https://www.google.com/fonts/specimen/Lato)
* [Roboto](https://www.google.com/fonts/specimen/Roboto)

Победителем вышел **TeX Gyre Heros**, т.к. он очень похож на Helvetica Neue, поддерживает кириллицу и дополнительно у него есть 4 condenced начертания.

<!-- cut -->

<figure>
	<a href="/demo/free_substitutes_for_helvetica_neue/">
	![TeX Gyre Heros — бесплатная альтернатива Helvetica Neue](/2014/free_substitution_for_helvetica_neue/helvetica-neue-vs-tex-gyre-heros.png)
	</a>
	<figcaption>Слева Helvetica Neue, справа TeX Gyre Heros</figcaption>
</figure>

<p style="text-align: center;"><a href="/demo/free_substitutes_for_helvetica_neue/" class="link-to-demo">Сравнение шрифтов</a></p>

Если всё же нужно купить Helvetica Neue для веба, обратите внимание на [Adobe Typekit](https://typekit.com/plans). У них дешевле.]]></description>
            <link>http://dmitriyfourier.github.io/2014/free_substitution_for_helvetica_neue/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/free_substitution_for_helvetica_neue/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Деплой Docpad-сайта на GitHub Pages]]></title>
            <description><![CDATA[При деплое [Docpad](http://docpad.org/)-сайта на [GitHub Pages](https://pages.github.com/) столкнулся с некоторыми проблемами.

1. Проблема с абсолютными путями: докпад по-умолчанию использует пути к ресурсам от корня домена, а на GH Pages url проекта будет выглядеть так `http://username.github.io/repository/`. Т.е. сайт находится в папке, а не в корне, и все пути к ресурсам недействительны. Конечно, можно купить собственное доменное имя, но это не мой случай. Нужно, чтобы на локалхосте url оставались абсолютными, а при деплое заменялись с учетом папки, в которую сайт деплоится.
2. [Плагин для деплоя](https://github.com/docpad/docpad-plugin-ghpages) не заработал сразу и без настроек, как обещает разработчик.
3. **Добавлено 6 мая 2018**: деплой из командной строки сломался после включения двухфакторной аутентификации на Гитхабе.

Так как у меня не всё прошло гладко и очевидно, решил написать эту инструкцию.

<!-- cut -->

## Проблема с абсолютными путями

Сначала разберёмся с абсолютными путями в докпаде.

Установим плагин [Get Url Plugin for DocPad](https://github.com/Hypercubed/docpad-plugin-geturl/).

Если ещё не создана, сделаем в конфиге докпада переменную `@site.url`:

```coffeescript
	templateData:
		site:
			# The production url of our website. Used in sitemap and rss feed
			url: "http://paulradzkov.github.io/docpad-simpleblog"
```

И добавим отдельную конфигурацию для «development» окружения:

```coffeescript
	# =================================
	# Environments

	environments:
		development:
			templateData:
				site:
					url: 'http://localhost:9778'
```

Эта переменная — `@site.url` — будет подставляться префиксом ко всем путям и ссылкам в зависимости от того, работаем мы на локалхосте или выкатываем сайт на хостинг.

Теперь нужно добавить хелпер «`@getUrl()`» ко всем «`href`» и «`src`» в шаблоне, в документах — везде, где встречаются абсолютные пути.

Например, было:

```html
<!-- DocPad Styles + Our Own -->
<%- @getBlock("styles").add(@site.styles).toHTML() %>

<script src="/vendor/modernizr.js"></script>
```

Стало:

```html
<!-- DocPad Styles + Our Own -->
<%- @getBlock("styles").add(@getUrl(@site.styles)).toHTML() %>

<script src="<%= @getUrl('/vendor/modernizr.js') %>"></script>
```

Было:

```html
<ul class="nav-list">
	<li><a href="/"><span>Blog</span></a></li>
	<li><a href="/docs"><span>Documentation</span></a></li>
	<li><a href="https://github.com/paulradzkov/docpad-simpleblog/issues"><span>Issues</span></a></li>
	<li><a href="https://github.com/paulradzkov/docpad-simpleblog"><span>Source Code</span></a></li>
</ul>
```

Стало:

```html
<ul class="nav-list">
	<li><a href="<%= @getUrl('/') %>"><span>Blog</span></a></li>
	<li><a href="<%= @getUrl('/docs') %>"><span>Documentation</span></a></li>
	<li><a href="https://github.com/paulradzkov/docpad-simpleblog/issues"><span>Issues</span></a></li>
	<li><a href="https://github.com/paulradzkov/docpad-simpleblog"><span>Source Code</span></a></li>
</ul>
```

Было:

```html
<ul class="meta-data">
	<li class="comments">
		<a href="<%= @document.path %>#disqus_thread" data-disqus-identifier="<%= @document.disqusid %>" >Комментарии</a>
	</li>
	<li class="tags-list">
		<% for tag in @document.tags : %>
			<a class="label-tag" href="<%= @getTagUrl(tag) %>"><%= tag %></a>
		<% end %>
	</li>
</ul>
```

Стало:

```html
<ul class="meta-data">
	<li class="comments">
		<a href="<%= @getUrl(@document.path) %>#disqus_thread" data-disqus-identifier="<%= @document.disqusid %>" >Комментарии</a>
	</li>
	<li class="tags-list">
		<% for tag in @document.tags : %>
			<a class="label-tag" href="<%= @getUrl(@getTagUrl(tag)) %>"><%= tag %></a>
		<% end %>
	</li>
</ul>
```

И так далее.

Теперь, когда мы запускаем <kbd class="cli" contenteditable="true" >&zwj;<span contenteditable="false">docpad run</span>&zwj;</kbd>, ко всем путям подставляется `@site.url` из девелоперского окружения — `http://localhost:9778`. А когда <kbd class="cli" contenteditable="true" >&zwj;<span contenteditable="false">docpad run --env static</span>&zwj;</kbd>, переменная `@site.url` равна нашему продакшен пути.

## Деплой на GitHub Pages

В репозитории создадим ветку «`gh-pages`». По инструкции это должна быть пустая ветка без истории, но об этом в дальнейшем позаботится плагин для деплоя.

<figure>
	![В репозитории проекта создадим ветку с именем «gh-pages»](/2014/deploy_docpad_site_to_github_pages/new_branch_gh-pages.png)
	<figcaption>В репозитории проекта создадим ветку с именем «`gh-pages`»</figcaption>
</figure>

Установим [GitHub Pages Deployer Plugin for DocPad](https://github.com/docpad/docpad-plugin-ghpages).

При попытке выполнить <kbd class="cli" contenteditable="true">&zwj;<span contenteditable="false">docpad deploy-ghpages --env static</span>&zwj;</kbd> у меня появляется ошибка:

<figure>
	![could not read Username for ’http://github.com’: No such file or directory](/2014/deploy_docpad_site_to_github_pages/gh-pages_deploy_error.png)
	<figcaption>`could not read Username for ’http://github.com’: No such file or directory`</figcaption>
</figure>

Плагин не смог соединиться с моим аккаунтом на гитхабе. Чтобы показать плагину правильный путь с логином и паролем, добавим новый «remote» для репозитория. Для этого в консоли git выполним:

<p><kbd class="cli" contenteditable="true" >&zwj;<span contenteditable="false">git remote add deploy <span>https://</span>login:password@github.com/repo_owner/repo_name.git</span>&zwj;</kbd></p>

Где «`deploy`» — это название удаленного репозитория. Можно выбрать любое, но переопределять «origin» я бы не советовал: у меня от этого локальная копия репозитория потеряла связь с Гитхабом.

«`login`» и «`password`» — данные вашего аккаунта на Гитхабе.

«`github.com/repo_owner/repo_name.git`» — путь к репозиторию проекта, в котором у вас есть права на запись. Это не обязательно должен быть ваш репозиторий, если вы коллаборатор, и у вас есть доступ на запись — вы можете деплоить туда проект.

<figure>
	![Добавление нового «remote» c логином и паролем](/2014/deploy_docpad_site_to_github_pages/adding_another_remote.png)
	<figcaption>Добавление нового «remote» c логином и паролем. Эту процедуру нужно выполнить один раз для каждого локального репозитория</figcaption>
</figure>

А в конфиге докпада пропишем настройки для плагина:

```coffeescript
	# Plugins configurations
	plugins:
		ghpages:
			deployRemote: 'deploy'
			deployBranch: 'gh-pages'
```

Теперь можно выкатывать сайт:

<kbd class="cli" contenteditable="true" >&zwj;<span contenteditable="false">docpad deploy-ghpages --env static</span>&zwj;</kbd>

## Двухфакторная аутентификация

**Добавлено 6 мая 2018**

Когда я включил двухфакторную аутентификацию на Гитхабе, деплой из командной строки перестал работать. Чтобы починить, вместо вашего пароля в настройках remote нужно подставить сгенерированный токен. Сгенерируйте его по этой [инструкции](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/). Если кратко:

1. На Гитхабе кликните по вашему аватару, потом **Settings** → **Developer settings** → **Personal access tokens** → **Generate new token**.
2. Дайте токену любое имя, например, «Mac terminal» или «Windows cmd».
3. Поставьте уровень доступа **repo**.
4. Нажмите **Generate token**.
5. Скопируйте полученный токен. Когда вы уйдете с этой страницы, токен уже нельзя будет посмотреть.

Вам нужно добавить новый «remote» (или заменить существующий) с токеном вместо пароля:

<p><kbd class="cli" contenteditable="true" >&zwj;<span contenteditable="false">git remote add deploy <span>https://</span>login:<mark>token</mark>@github.com/repo_owner/repo_name.git</span>&zwj;</kbd></p>

И всё снова заработает.]]></description>
            <link>http://dmitriyfourier.github.io/2014/deploy_docpad_site_to_github_pages/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/deploy_docpad_site_to_github_pages/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Краткое руководство по Маркдауну]]></title>
            <description><![CDATA[<p><strong>12 июля 2015: Обновил руководство до Github Flavoured Markdown. Предыдущее <a href="http://codepen.io/paulradzkov/pen/ZGoLgr" target="_blank" rel="noopener">руководство с традиционным Маркдауном</a>.</strong>
</p>

<p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">Официальное руководство</a> по синтаксису Markdown мне кажется слишком длинным и не слишком наглядным, поэтому я составил краткое руководство, которое поможет выучить или повторить синтаксис Маркдауна за час.</p>

<!-- cut -->

<p>Кроме традиционного Маркдауна у разработчиков получил распространение дополненный и улучшеный вариант языка — Github Flavoured Markdown, сокращенно GFM.</p>

<p>Основные отличия GFM и чистого Маркдауна:</p>
<ul>
    <li>добавили таблицы, которых не было в оригинальном Маркдауне;</li>
    <li>добавили альтернативный синтаксис для вставки блоков кода: теперь можно не ставить 4 пробела перед каждой строкой кода, также можно явно указать язык кода;</li>
    <li>добавили зачеркнутый текст.</li>
</ul>

<p><a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="noopener">Полный список отличий</a> на Гитхабе.</p>

<div class="raw-output">
```markdown

# GitHub-Flavored Markdown

## Краткое руководство

Абзацы создаются при помощи пустой строки. Если вокруг текста сверху и снизу есть пустые строки, то текст превращается в абзац.

Чтобы сделать перенос строки вместо абзаца,  
нужно поставить два пробела в конце предыдущей строки.

Заголовки отмечаются диезом `#` в начале строки, от одного до шести. Например:

# Заголовок первого уровня #
## Заголовок h2
### Заголовок h3
#### Заголовок h4
##### Заголовок h5
###### Заголовок h6

В декоративных целях заголовки можно «закрывать» с обратной стороны.

### Списки

Для разметки неупорядоченных списков можно использовать или `*`, или `-`, или `+`:

- элемент 1
- элемент 2
- элемент ...

Вложенные пункты создаются четырьмя пробелами перед маркером пункта:

* элемент 1
* элемент 2
    * вложенный элемент 2.1
    * вложенный элемент 2.2
* элемент ...

Упорядоченный список:

1. элемент 1
2. элемент 2
    1. вложенный
    2. вложенный
3. элемент 3
4. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

На самом деле не важно как в коде пронумерованы пункты, главное, чтобы перед элементом списка стояла цифра (любая) с точкой. Можно сделать и так:

0. элемент 1
0. элемент 2
0. элемент 3
0. элемент 4

Список с абзацами:

* Раз абзац. Lorem ipsum dolor sit amet, consectetur adipisicing elit.

* Два абзац. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

* Три абзац. Ea, quis, alias nobis porro quos laborum minus sed fuga odio dolore natus quas cum enim necessitatibus magni provident non saepe sequi?

    Четыре абзац (Четыре пробела в начале или один tab).

### Цитаты

Цитаты оформляются как в емейлах, с помощью символа `>`.

> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
>
> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
> id sem consectetuer libero luctus adipiscing.

Или более ленивым способом, когда знак `>` ставится перед каждым элементом цитаты, будь то абзац, заголовок или пустая строка:

> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
>
> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.

В цитаты можно помещать всё что угодно, в том числе вложенные цитаты:

> ## This is a header.
>
> 1.   This is the first list item.
> 2.   This is the second list item.
>
> > Вложенная цитата.
>
> Here's some example code:
>
>     return shell_exec("echo $input | $markdown_script");

### Исходный код

В чистом Маркдауне блоки кода отбиваются 4 пробелами в начале каждой строки.

Но в GitHub-Flavored Markdown (сокращенно GFM) есть более удобный способ: ставим по три апострофа (на букве Ё) до и после кода. Также можно указать язык исходного кода.

` ` `html
<nav class="nav nav-primary">
  <ul>
    <li class="tab-conversation active">
      <a href="#" data-role="post-count" class="publisher-nav-color" data-nav="conversation">
        <span class="comment-count">0 комментариев</span>
        <span class="comment-count-placeholder">Комментарии</span>
      </a>
    </li>
    <li class="dropdown user-menu" data-role="logout">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown">
        <span class="dropdown-toggle-wrapper">
          <span>
            Войти
          </span>
        </span>
        <span class="caret"></span>
      </a>
    </li>
  </ul>
</nav>
` ` `

Самое приятное, что в коде не нужно заменять угловые скобки `< >` и амперсанд `&` на их html-сущности.

### Инлайн код

Для вставки кода внутри предложений нужно заключать этот код в апострофы (на букве Ё). Пример: `<html class="ie no-js">`.

Если внутри кода есть апостроф, то код надо обрамить двойными апострофами: ``There is a literal backtick (`) here.``

### Горизонтальная черта

`hr` создается тремя звездочками или тремя дефисами.

***

### Ссылки

Это встроенная [ссылка с title элементом](http://example.com/link "Я ссылка"). Это — [без title](http://example.com/link).

А вот [пример][1] [нескольких][2] [ссылок][id] с разметкой как у сносок. Прокатит и [короткая запись][] без указания id.

[1]: http://example.com/ "Optional Title Here"
[2]: http://example.com/some
[id]: http://example.com/links (Optional Title Here)
[короткая запись]: http://example.com/short

Вынос длинных урлов из предложения способствует сохранению читабельности исходника. Сноски можно располагать в любом месте документа.

### Emphasis

Выделять слова можно при помощи `*` и `_`. Одним символ для наклонного текста, два символа для жирного текста, три — для наклонного и жирного одновременно.

Например, это _italic_ и это тоже *italic*. А вот так уже __strong__, и так тоже **strong**. А так ***жирный и наклонный*** одновременно.

### Зачеркивание

В GFM добавлено зачеркивание текста: две тильды `~` до и после текста.

~~Зачеркнуто~~

## Картинки

Картинка без `alt` текста

![](http://placehold.it/150x100)

Картинка с альтом и тайтлом:

![Alt text](http://placehold.it/150x100 "Можно задать title")

Запомнить просто: синтаксис как у ссылок, только перед открывающей квадратной скобкой ставится восклицательный знак.

Картинки «сноски»:

![Картинка][image1]
![Картинка][image2]
![Картинка][image3]

[image1]: http://placehold.it/250x100
[image2]: http://placehold.it/200x100
[image3]: http://placehold.it/150x100

Картинки-ссылки:

[![Alt text](http://placehold.it/150x100)](http://example.com/)


## Использование HTML внутри Markdown

Mожно смешивать Markdown и HTML. Если на какие-то элементы нужно поставить классы или атрибуты, смело используем HTML:

> Выделять слова можно при помощи * и _ . Например, это <em class="a1">italic</em> и это тоже <i class="a1">italic</i>. А вот так уже <b>strong</b>, и так тоже <strong>strong</strong>.

Можно и наоборот, внутри HTML-тегов использовать Маркдаун.

<section class="someclass">

### Пример Маркдауна внутри HTML

Выделять слова можно при помощи `*` и `_` . Например, это _italic_ и это тоже *italic*. А вот так уже __strong__, и так тоже **strong**.

</section>

### Таблицы

В чистом Маркдауне нет синтаксиса для таблиц, а в GFM есть.

First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell

Для красоты можно и по бокам линии нарисовать:

| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |

Можно управлять выравниванием столбцов при помощи двоеточия.

| Left-Aligned  | Center Aligned  | Right Aligned |
|:------------- |:---------------:| -------------:|
| col 3 is      | some wordy text |     **$1600** |
| col 2 is      | centered        |         $12   |
| zebra stripes | are neat        |        ~~$1~~ |

Внутри таблиц можно использовать ссылки, наклонный, жирный или зачеркнутый текст.

Для всего остального есть обычный HTML.


```
</div>

<div class="markdown-cheatsheet">
  <div class="markdown-cheatsheet-inner">
    <div id="in">
      <form>
        <textarea id="code" contentEditable="true">
# GitHub-Flavored Markdown

## Краткое руководство

Абзацы создаются при помощи пустой строки. Если вокруг текста сверху и снизу есть пустые строки, то текст превращается в абзац.

Чтобы сделать перенос строки вместо абзаца,  
нужно поставить два пробела в конце предыдущей строки.

Заголовки отмечаются диезом `#` в начале строки, от одного до шести. Например:

# Заголовок первого уровня #
## Заголовок h2
### Заголовок h3
#### Заголовок h4
##### Заголовок h5
###### Заголовок h6

В декоративных целях заголовки можно «закрывать» с обратной стороны.

### Списки

Для разметки неупорядоченных списков можно использовать или `*`, или `-`, или `+`:

- элемент 1
- элемент 2
- элемент ...

Вложенные пункты создаются четырьмя пробелами перед маркером пункта:

* элемент 1
* элемент 2
    * вложенный элемент 2.1
    * вложенный элемент 2.2
* элемент ...

Упорядоченный список:

1. элемент 1
2. элемент 2
    1. вложенный
    2. вложенный
3. элемент 3
4. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

На самом деле не важно как в коде пронумерованы пункты, главное, чтобы перед элементом списка стояла цифра (любая) с точкой. Можно сделать и так:

0. элемент 1
0. элемент 2
0. элемент 3
0. элемент 4

Список с абзацами:

* Раз абзац. Lorem ipsum dolor sit amet, consectetur adipisicing elit.

* Два абзац. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

* Три абзац. Ea, quis, alias nobis porro quos laborum minus sed fuga odio dolore natus quas cum enim necessitatibus magni provident non saepe sequi?

    Четыре абзац (Четыре пробела в начале или один tab).

### Цитаты

Цитаты оформляются как в емейлах, с помощью символа `>`.

> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
>
> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
> id sem consectetuer libero luctus adipiscing.

Или более ленивым способом, когда знак `>` ставится перед каждым элементом цитаты, будь то абзац, заголовок или пустая строка:

> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
>
> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.

В цитаты можно помещать всё что угодно, в том числе вложенные цитаты:

> ## This is a header.
>
> 1.   This is the first list item.
> 2.   This is the second list item.
>
> > Вложенная цитата.
>
> Here's some example code:
>
>     return shell_exec("echo $input | $markdown_script");

### Исходный код

В чистом Маркдауне блоки кода отбиваются 4 пробелами в начале каждой строки.

Но в GitHub-Flavored Markdown (сокращенно GFM) есть более удобный способ: ставим по три апострофа (на букве Ё) до и после кода. Также можно указать язык исходного кода.

```html
<nav class="nav nav-primary">
  <ul>
    <li class="tab-conversation active">
      <a href="#" data-role="post-count" class="publisher-nav-color" data-nav="conversation">
        <span class="comment-count">0 комментариев</span>
        <span class="comment-count-placeholder">Комментарии</span>
      </a>
    </li>
    <li class="dropdown user-menu" data-role="logout">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown">
        <span class="dropdown-toggle-wrapper">
          <span>
            Войти
          </span>
        </span>
        <span class="caret"></span>
      </a>
    </li>
  </ul>
</nav>
```

Самое приятное, что в коде не нужно заменять угловые скобки `< >` и амперсанд `&` на их html-сущности.

### Инлайн код

Для вставки кода внутри предложений нужно заключать этот код в апострофы (на букве Ё). Пример: `<html class="ie no-js">`.

Если внутри кода есть апостроф, то код надо обрамить двойными апострофами: ``There is a literal backtick (`) here.``

### Горизонтальная черта

`hr` создается тремя звездочками или тремя дефисами.

***

### Ссылки

Это встроенная [ссылка с title элементом](http://example.com/link "Я ссылка"). Это — [без title](http://example.com/link).

А вот [пример][1] [нескольких][2] [ссылок][id] с разметкой как у сносок. Прокатит и [короткая запись][] без указания id.

[1]: http://example.com/ "Optional Title Here"
[2]: http://example.com/some
[id]: http://example.com/links (Optional Title Here)
[короткая запись]: http://example.com/short

Вынос длинных урлов из предложения способствует сохранению читабельности исходника. Сноски можно располагать в любом месте документа.

### Emphasis

Выделять слова можно при помощи `*` и `_`. Одним символ для наклонного текста, два символа для жирного текста, три — для наклонного и жирного одновременно.

Например, это _italic_ и это тоже *italic*. А вот так уже __strong__, и так тоже **strong**. А так ***жирный и наклонный*** одновременно.

### Зачеркивание

В GFM добавлено зачеркивание текста: две тильды `~` до и после текста.

~~Зачеркнуто~~

## Картинки

Картинка без `alt` текста

![](//placehold.it/150x100)

Картинка с альтом и тайтлом:

![Alt text](//placehold.it/150x100 "Можно задать title")

Запомнить просто: синтаксис как у ссылок, только перед открывающей квадратной скобкой ставится восклицательный знак.

Картинки «сноски»:

![Картинка][image1]
![Картинка][image2]
![Картинка][image3]

[image1]: //placehold.it/250x100
[image2]: //placehold.it/200x100
[image3]: //placehold.it/150x100

Картинки-ссылки:

[![Alt text](//placehold.it/150x100)](http://example.com/)


## Использование HTML внутри Markdown

Mожно смешивать Markdown и HTML. Если на какие-то элементы нужно поставить классы или атрибуты, смело используем HTML:

> Выделять слова можно при помощи * и _ . Например, это <em class="a1">italic</em> и это тоже <i class="a1">italic</i>. А вот так уже <b>strong</b>, и так тоже <strong>strong</strong>.

Можно и наоборот, внутри HTML-тегов использовать Маркдаун.

<section class="someclass">

### Пример Маркдауна внутри HTML

Выделять слова можно при помощи `*` и `_` . Например, это _italic_ и это тоже *italic*. А вот так уже __strong__, и так тоже **strong**.

</section>

### Таблицы

В чистом Маркдауне нет синтаксиса для таблиц, а в GFM есть.

First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell

Для красоты можно и по бокам линии нарисовать:

| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |

Можно управлять выравниванием столбцов при помощи двоеточия.

| Left-Aligned  | Center Aligned  | Right Aligned |
|:------------- |:---------------:| -------------:|
| col 3 is      | some wordy text |     **$1600** |
| col 2 is      | centered        |         $12   |
| zebra stripes | are neat        |        ~~$1~~ |

Внутри таблиц можно использовать ссылки, наклонный, жирный или зачеркнутый текст.

Для всего остального есть обычный HTML.

        </textarea>
      </form>
    </div>
    <div id="out"></div>
    <div id="menu">
      <span>Save As</span>
      <div id="saveas-markdown">
        <svg height="64" width="64" xmlns="http://www.w3.org/2000/svg">
          <g transform="scale(0.0625)">
            <path d="M950.154 192H73.846C33.127 192 0 225.12699999999995 0 265.846v492.308C0 798.875 33.127 832 73.846 832h876.308c40.721 0 73.846-33.125 73.846-73.846V265.846C1024 225.12699999999995 990.875 192 950.154 192zM576 703.875L448 704V512l-96 123.077L256 512v192H128V320h128l96 128 96-128 128-0.125V703.875zM767.091 735.875L608 512h96V320h128v192h96L767.091 735.875z" />
          </g>
        </svg>

        <span>Markdown</span>
      </div>
      <div id="saveas-html">
        <svg height="64" width="64" xmlns="http://www.w3.org/2000/svg">
          <g transform="scale(0.0625) translate(64,0)">
            <path d="M608 192l-96 96 224 224L512 736l96 96 288-320L608 192zM288 192L0 512l288 320 96-96L160 512l224-224L288 192z" />
          </g>
        </svg>

        <span>HTML</span>
      </div>
      <a id="close-menu">&times;</a>
    </div>
  </div>
</div>

<p>Для создания демки использован <a href="https://github.com/jbt/markdown-editor">Live Markdown Editor</a>. </p>

<p>Дополнительные функции:</p>
<ul>
  <li><kbd>Ctrl/Cmd + S</kbd> — сохранить маркдаун-код как файл;</li>
  <li><kbd>Ctrl/Cmd + Shift + S</kbd> — выбрать, как сохранить: макрдаун или html;</li>
  <li>Перетянуть файл в панель кода, чтобы загрузить его;</li>
  <li>Контент файла сохраняется в URL, чтобы можно было поделиться ссылкой.</li>
</ul>]]></description>
            <link>http://dmitriyfourier.github.io/2014/markdown_cheatsheet/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/markdown_cheatsheet/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[О каких дизайнерах мечтают верстальщики]]></title>
            <description><![CDATA[В [совете](http://artgorbunov.ru/bb/soviet/20140206/) Николай Товеровский классифицировал верстальщиков на три категории: «Неандертальцы», «Планктон» и «Суперзвёзды».

На мой взгляд, между «Планктоном» и «Суперзвёздами» должны быть «Мастера», которые замечают все проблемы, советуются с дизайнерами, предлагают варианты, но не требуют «нарисовать макетик» и, пока ещё, не берут на себя ответственность дорабатывать макет самостоятельно. Таким специалистам достаточно на словах объяснить, что будет в крайних ситуациях и как должны вести себя элементы сайта в непрорисованных состояниях. Они всё поймут и сделают как надо.

А вот о каких дизайнерах мечтают верстальщики…

<!-- cut -->

***

Бывает дизайнер-Суперзвезда, который отдаёт 15 страниц макета и страницу, на которой прорисованы все базовые элементы: заголовки, списки, цитаты, таблички, формы с полями ввода, чекбоксами и кнопочками.

Сверстаешь такую страницу, а дальше все остальные пятнадцать страниц автоматически «собираются» пиксель-в-пиксель как на макете, только теги добавляй и новые стили дописывай. И в стилях при этом ничего не приходится обнулять, переписывать, идти на компромисcы.

И каждая страница макета согласуется с сеткой, которую выбрал для сайта дизайнер, и тебе не приходится подгонять размеры элементов от страницы к странице. А на полях макетов прорисованы разные состояния элементов.

И ты знаешь, что если в исходнике растровый слой, его надо нарезать картинкой, а если векторный — верстать, используя CSS. И каждый растровый элемент сайта или склеен в один слой, или является смарт-объектом. И нет в макете скрытых слоёв, которые не пригодились дизайнеру, а все растровые фоны даны с запасом на резину. И все шейпы попадают в пиксели. И тени на элементах в нормальном режиме наложения, а не каком-нибудь «Multiply». И вообще в слоях порядок.

Плюс ко всему этому прилагаются нестандартные шрифты из макета, чтобы верстальщик не искал их двадцать минут в интернете, и сторонние иконки, чтобы не нарезать их снова.

И оказывается, что 15 страниц — не так уж много. И верстаются они легко и быстро, что даже кажется, будто тебя обманули, что этот проект уже когда-то был свёрстан, а потом дизайнер его заскриншотил и заново отрисовал.

Такой дизайнер способен подтянуть верстальщика на новый уровень всего за несколько проектов.]]></description>
            <link>http://dmitriyfourier.github.io/2014/designer-superstar/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/designer-superstar/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Захват экрана в GIF]]></title>
            <description><![CDATA[<p>Рекомендую замечательную маленькую программку для записи области экрана в GIF — <a href="http://www.cockos.com/licecap/" target="_blank" rel="noopener"><strong>LICEcap</strong></a>. Она должна быть полезна тестерам и разработчикам — лучше показать / увидеть баг в динамике, чем расписывать последовательность шагов для воспроизведения бага.</p>

<p>А ещё можно сохранять в гифки смешные моменты из фильмов.</p>

<!-- cut -->

<p>Пользоваться легко, смотрите сами:</p>

<figure>
    <img src="/2014/capture_screen_to_gif/licecap-demo.gif" alt="LICEcap — захват экрана в GIF">
    <figcaption><p>Захват экрана в GIF в программе LICEcap</p></figcaption>
</figure>

<p>Настроек минимум, но есть всё самое необходимое: можно настроить область захвата с точностью до пикселя, выбрать количество кадров в секунду, количество повторений GIF-анимации, показывать при записи клики или нет, показывать секундомер на гифке.</p>

<p>Если 256 цветов на кадр не хватает, можно сделать захват в собственный формат программы .LCF и потом воспроизвести и отрендерить в видео формат при помощи другой, уже платной, программы этого же разработчика.</p>

<p>LICEcap бесплатна. Есть версия для Windows и OS X.</p>

<p>
    <a href="http://www.cockos.com/licecap/" target="_blank" rel="noopener" class="link-to-demo">Скачать с сайта разработчика</a>
</p>]]></description>
            <link>http://dmitriyfourier.github.io/2014/capture_screen_to_gif/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/capture_screen_to_gif/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Font-weight: bolder для шрифтов со множеством начертаний]]></title>
            <description><![CDATA[<p>Если вы используете шрифт со множеством начертаний, то вам, вероятно, захочется, чтобы теги <code class="hljs-tag">strong</code> и <code class="hljs-tag">b</code> не увеличивали жирность шрифта до фиксированного значения <code class="hljs-rule"><span class="hljs-attribute">font-weight</span>:<span class="hljs-number">700</span></code>, как это происходит по-умолчанию, а использовали промежуточные значения, рассчитанные исходя из жирности шрифта родительского элемента.</p>
<p>Ведь не очень красиво, когда в ультратонком шрифте появляются жирные кляксы тегов <code class="hljs-tag">strong</code>.</p>

<!-- cut -->

<p>Возьмём для примера Open Sans.</p>

<figure>
  <img src="/2014/font-weight_bolder/open-sans.png" width="847" height="345" alt="Open Sans и все его начертания">
  <figcaption>
  	<p>Open Sans имеет пять начертаний: Light 300, Normal 400, Semi-Bold 600, Bold 700 и Extra-Bold 800. <br> Цифры соответствуют значению <code class="hljs-attribute">font-weight</code>.</p>
  </figcaption>
</figure>

<p>Основной текст имеет начертание Light 300, заголовки и цитаты — Normal 400, а промо-блок — Semi-Bold 600:</p>

<pre class="highlight"><code class="hljs css"><span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Open Sans'</span>, sans-serif;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;
}
<span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span>, <span class="hljs-selector-tag">h4</span>, <span class="hljs-selector-tag">h5</span>, <span class="hljs-selector-tag">h6</span>,
<span class="hljs-selector-tag">blockquote</span> {
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;
}
<span class="hljs-selector-class">.promo</span> {
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">600</span>;
}
</code></pre>

<p>Тег <code class="hljs-tag">strong</code> может встечаться и в основном тексте, и в цитатах, и промо-блоке. Надо это учесть.</p>

<p>По-умолчанию:</p>

<pre class="highlight"><code class="hljs css"><span class="hljs-selector-tag">strong</span>, <span class="hljs-selector-tag">b</span> {
    <span class="hljs-attribute">font-weight</span>: bold; <span class="hljs-comment">/* bold = 700 */</span>
}
</code></pre>

<p>А нам хочется, чтобы у <code class="hljs-tag">strong</code> и <code class="hljs-tag">b</code> для основного текста было Normal 400, для цитат и заголовков — Bold 700, а для промо блока — Extra-Bold 800. Это сохранит контраст между жирным и нежирным текстом примерно равным во всех случаях.</p>

<p>Уверен, многие пробовали использовать <code class="css"><span class="hljs-tag">strong</span> <span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">font-weight</span>:<span class="hljs-value"> bolder</span></span>;<span class="hljs-rule">}</span></span></code>, но это не принесло ожидаемого результата — текст стал ещё жирнее, чем ожидалось.</p>

<p>А всё потому, что согласно <a href="http://www.w3.org/TR/CSS2/fonts.html#font-boldness" target="_blank" rel="noopener">спецификации</a>, значение <code class="hljs-rule"><span class="hljs-value">bolder</span></code>  (<code class="hljs-rule"><span class="hljs-value">lighter</span></code>) увеличивает (уменьшает) <em>унаследованное</em> значение <code class="hljs-attribute">font-weight</code> до следующего возможного для данного шрифта значения, согласно следующей таблице.</p>

<figure>
<table style="margin: auto;">
    <tr>
        <th>Наследуемое значение</th><th>bolder</th><th>lighter</th>
    </tr>
    <tr>
        <td>100</td><td>400</td><td>100</td>
    </tr>
    <tr>
        <td>200</td><td>400</td><td>100</td>
    </tr>
    <tr>
        <td>300</td><td>400</td><td>100</td>
    </tr>
    <tr>
        <td>400</td><td>700</td><td>100</td>
    </tr>
    <tr>
        <td>500</td><td>700</td><td>100</td>
    </tr>
    <tr>
        <td>600</td><td>900</td><td>400</td>
    </tr>
    <tr>
        <td>700</td><td>900</td><td>400</td>
    </tr>
    <tr>
        <td>800</td><td>900</td><td>700</td>
    </tr>
    <tr>
        <td>900</td><td>900</td><td>700</td>
    </tr>
</table>
<figcaption><p>Значения «bolder» и «lighter» в зависимости от наследуемого значения.</p></figcaption>
</figure>

<p><del>Но в браузерной CSS прописано <code class="css"><span class="hljs-tag">strong</span>, <span class="hljs-tag">b</span> <span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">font-weight</span>:<span class="hljs-value">bold</span></span>;<span class="hljs-rule">}</span></span></code>, т.е. <em>унаследуется</em> значение «700», а потом оно ещё и увеличивается до «900». Поэтому кажется, что <code class="hljs-rule"><span class="hljs-value">bolder</span></code> работает неправильно.</del></p>

<blockquote>
    <p><strong>Добавлено 22 января 2016</strong></p>
    <p>На самом деле это был баг и он присутствовал во всех браузерах на момент написания статьи. Позже баги в браузерах были исправлены.
        А <a href="https://github.com/necolas/normalize.css/pull/342">мой пулл-реквест</a> был принят в <a href="https://github.com/necolas/normalize.css">normalize.css</a>.</p>
</blockquote>

<p>Исправить это можно так:</p>

<pre class="highlight"><code class="hljs css"><span class="hljs-comment">/* сбрасываем стандартное «bold»,
шрифт становится таким же как его родительский элемент */</span>
<span class="hljs-selector-tag">strong</span>, <span class="hljs-selector-tag">b</span> {
  <span class="hljs-attribute">font-weight</span>: inherit;
}

<span class="hljs-comment">/* теперь bolder будет вычисляться исходя из веса шрифта родительского элемента */</span>
<span class="hljs-selector-tag">strong</span>, <span class="hljs-selector-tag">b</span> {
  <span class="hljs-attribute">font-weight</span>: bolder;
}
</code></pre>

<p>Именно так, как два отдельных правила. Первое обнуляет значение <code class="hljs-attribute">font-weight</code> из браузерной таблицы стилей, второе задаёт жирность уже в относительных, а не абсолютных единицах.</p>

<p>Теперь нам не придётся заботиться о вложенности элементов — каскад всё сделает автоматически. Мы можем вкладывать теги <code class="hljs-tag">strong</code> друг в друга.</p>

<figure>
    <a href="http://cssdeck.com/labs/x20utix0" target="_blank" rel="noopener"><img src="/2014/font-weight_bolder/nested-tags-with-font-weight-bolder.png" alt=""></a>
    <figcaption>
        <p>Вложенные теги «strong». Толщина шрифта определяется исходя из значения родительского элемента.</p>
        <p style="text-align: center;"><a href="http://cssdeck.com/labs/x20utix0" target="_blank" rel="noopener" class="link-to-demo">Демка</a></p>
    </figcaption>
</figure>


<h2>Ограничения</h2>

<p>Используя относительные значения <code class="hljs-attribute">font-weight</code> мы получаем только по три градации жирности шрифта для <code class="hljs-rule"><span class="hljs-value">bolder</span></code> и <code class="hljs-rule"><span class="hljs-value">lighter</span></code> соответственно. Спецификация не гарантирует, что браузеры правильно сопоставят названия начертаний и числовые значения. Не гарантирует, что для шрифта найдётся более жирное или более тонкое начертание. У некоторых шрифтов всего два начертания, у некоторых может быть восемь.</p>

<p>Единственной гарантией при использовании <code class="hljs-rule"><span class="hljs-value">bolder</span></code> / <code class="hljs-rule"><span class="hljs-value">lighter</span></code> является то, что шрифт при значении «bolder» не будет тоньше, чем более легкие начертания этого шрифта, а при значении «lighter» будет не толще, чем более жирные начертания этого шрифта.</p>

<p>Чтобы более тонко настроить вес шрифта, надо использовать абсолютные значения.</p>

<h2>Баги</h2>

<p>Если у вас шрифт установлен в системе, но не подключен через <code class="hljs-at_rule">@<span class="hljs-keyword">font-face</span></code>, то Google Chrome определяет только Normal и Bold начертания шрифта. Чтобы локальный шрифт заработал, нужно дополнительно указать его <code class="hljs-attribute">font-family</code>.</p>

<pre class="highlight"><code class="hljs css"><span class="hljs-selector-class">.fw300</span> {
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Open Sans Light"</span>, <span class="hljs-string">"Open Sans"</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;
}
<span class="hljs-selector-class">.fw600</span> {
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Open Sans SemiBold"</span>, <span class="hljs-string">"Open Sans"</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">600</span>;
}
</code></pre>]]></description>
            <link>http://dmitriyfourier.github.io/2014/font-weight_bolder/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/font-weight_bolder/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Параметры subject и body в mailto ссылках]]></title>
            <description><![CDATA[В письмах от сервисов и электронных магазинов, приходящих в ответ на заказ услуги или покупку товара, часто есть подобная фраза:

>«Если у Вас возникли любые вопросы касательно вашего заказа, пожалуйста, свяжитесь со Службой поддержки по телефону <a href="tel:XXXX XXX XXXX">XXXX XXX XXXX</a> или напишите по адресу <a href="mailto:customerservices@sitename.com?subject=Заказ XXXXX&amp;body=Мой номер заказа XXXXX" class="breakall">customerservices@sitename.com</a>. Не забудьте сообщить ваш номер заказа.

Создавая шаблоны для таких писем, не поленитесь прописать этот самый номер заказа (и любую другую нужную службе поддержки информацию) в параметры mailto ссылки:

```
<a href="mailto:customerservices@sitename.com?subject=Заказ XXXXX&amp;body=Мой номер заказа XXXXX">customerservices@sitename.com</a>
```

Теперь при клике на адрес электронной почты в новом сообщении номер заказа подставится и в тему письма, и в текст сообщения.

Мелочь, но она сэкономит вашим покупателям пару лишних действий. Особенно актуально это для тех, кто пишет письмо с мобильника.]]></description>
            <link>http://dmitriyfourier.github.io/2014/mailto_parameters/</link>
            <guid isPermaLink="true">http://dmitriyfourier.github.io/2014/mailto_parameters/</guid>
            <dc:creator><![CDATA[Павел Радьков]]></dc:creator>
            <pubDate>Sun, 16 May 2021 16:12:05 GMT</pubDate>
        </item>
    </channel>
</rss>